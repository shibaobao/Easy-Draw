!function(t){var e={};function i(s){if(e[s])return e[s].exports;var n=e[s]={i:s,l:!1,exports:{}};return t[s].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=t,i.c=e,i.d=function(t,e,s){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(s,n,function(e){return t[e]}.bind(null,n));return s},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=0)}([function(t,e,i){"use strict";i.r(e);const s={lineWidth:2,fillStyle:"#FFFFFF",strokeStyle:"#0E71EB",width:8},n={lineWidth:2,fillStyle:"#27AE60",radius:4},h={lineWidth:2,fillStyle:"rgba(14, 113, 235, 0.25)",strokeStyle:"#0E71EB"},o={lineWidth:2,fillStyle:"rgba(14, 113, 235, 0.8)",strokeStyle:"rgba(14, 113, 235, 0.8)"},a={lineWidth:1,strokeStyle:"#0E71EB"};var r=class{constructor(t){this.id=t.id,this.type=t.type,this.edit=t.edit||!0,this.points=t.points||[],this.temporaryPoints=[],this.temporaryPointsWithoutZoomAndOffset=[],this.path=t.path||"",this.SVGPath="",this.handlePoints=[],this.rotationHandlePoint=[],this.clickedHandlePointIndex=null,this.clickedShape=!1,this.clickedShapePoint=[],this.clickedHandlePoint=!1,this.freeDraw=t.freeDraw,this.handlePointStyle=t.handlePointStyle,this.shapeStyle=t.shapeStyle,this.shape=null}_initShape(){this.handlePointStyle||(this.handlePointStyle=s),this.shapeStyle||(this.shapeStyle=h)}_trigger(t){const{type:e}=t;switch(e){case"mousedown":this._handleMouseDown&&"function"==typeof this._handleMouseDown&&this._handleMouseDown(t);break;case"mousemove":this._handleMouseMove&&"function"==typeof this._handleMouseMove&&this._handleMouseMove(t);break;case"mouseup":this._handleMouseUp&&"function"==typeof this._handleMouseUp&&this._handleMouseUp(t);break;case"keydown":this._handleKeydown&&"function"==typeof this._handleKeydown&&this._handleKeydown(t)}}_drawRotationHandlePoint(t,e,i,s){const n=new Path2D;return n.arc(t,e,i,0,2*Math.PI,!1),this.freeDraw._updateCtxStyle(s),this.freeDraw.ctx.fill(n),this.freeDraw.ctx.stroke(n),n}_drawRectPoint(t,e,i,s){const n=new Path2D;return n.rect(t-i/2,e-i/2,i,i),this.freeDraw._updateCtxStyle(s),this.freeDraw.ctx.fill(n),this.freeDraw.ctx.stroke(n),n}_drawLine(t,e,i){const s=`M${t[0]},${t[1]}L${e[0]},${e[1]}`,n=new Path2D(s);return this.freeDraw._updateCtxStyle(i),this.freeDraw.ctx.fill(n),this.freeDraw.ctx.stroke(n),n}_drawCirclePoint(t,e,i,s){const n=new Path2D;return n.arc(t,e,i,0,2*Math.PI,!1),this.freeDraw._updateCtxStyle(s),this.freeDraw.ctx.fill(n),this.freeDraw.ctx.stroke(n),n}_includes(t,e){return this._pointInHandlePoints(t,e)||this._pointInShape(t,e)}_handleMouseDown(t){const{offsetX:e,offsetY:i}=t;this._pointInHandlePoints(e,i)?(this.clickedHandlePoint=!0,this.clickedShapePoint=[],this.clickedShape=!1,"polygon"===this.type&&this._polygonMouseDown(t)):this._pointInShape(e,i)?(this.clickedHandlePoint=!1,this.clickedShapePoint=[e,i],this.clickedShape=!0):"polygon"===this.type&&this._polygonMouseDown(t)}_handleMouseUp(){this.clickedShape=!1,this.clickedHandlePoint=!1,this.clickedShapePoint=[]}_pointInShape(t,e){if(!this.shape)return!1;for(let i of this.temporaryPointsWithoutZoomAndOffset)if(t===i[0]&&e===i[1])return!1;return this.freeDraw.ctx.isPointInPath(this.shape,t,e)}_pointInHandlePoints(t,e){let i=!1;if(this.edit){let s=null;for(let n=0;n<this.handlePoints.length;n++)if(this.freeDraw.ctx.isPointInPath(this.handlePoints[n].obj,t,e)){i=!0,s=n;break}this.clickedHandlePointIndex=s}return i}editShape(){return this.shapeStyle=h,this.edit=!0,this.freeDraw._updateModel("edit",this.id),this.freeDraw._refreshShapesInCanvas(),this._backupData(),this}finish(){return this.edit=!1,this.isCreate=!1,this.freeDraw._updateModel("view"),this.shapeStyle=o,this._toSVGPath&&"function"==typeof this._toSVGPath&&this._toSVGPath(),this.freeDraw._refreshShapesInCanvas(),this}cancelEdit(){return this.shapeStyle=o,this.edit=!1,this.freeDraw._updateModel("view"),this._rollbackData(),this.freeDraw._refreshShapesInCanvas(),this}};var l=class extends r{constructor(t){super(t),this.startPoint=t.startPoint||[],this.width=t.width,this.height=t.height,this.startPointBackup=[],this.widthBackup=null,this.heightBackup=null,this.pointsBackup=[],this._initRect()}_initRect(){this._initShape(),this.startPoint.length>0&&this.width&&this.height&&this._draw()}_draw(){this._generateHandlePointsByPoints(),this.shape=this._drawRect(),this.edit&&this._drawRectHandlePoints()}_generateHandlePointsByPoints(){const{startPoint:t,width:e,height:i}=this.getZoomAndMove();this.handlePoints[0]={obj:null,point:t},this.handlePoints[1]={obj:null,point:[t[0]+e,t[1]]},this.handlePoints[2]={obj:null,point:[t[0]+e,t[1]+i]},this.handlePoints[3]={obj:null,point:[t[0],t[1]+i]}}_drawRectHandlePoints(){for(let t=0;t<this.handlePoints.length;t++)this.handlePoints[t].obj=this._drawRectPoint(this.handlePoints[t].point[0],this.handlePoints[t].point[1],this.handlePointStyle.width,{lineWidth:this.handlePointStyle.lineWidth,fillStyle:this.handlePointStyle.fillStyle,strokeStyle:this.handlePointStyle.strokeStyle})}_drawRect(){const{startPoint:t,width:e,height:i}=this.getZoomAndMove(),s=new Path2D;return s.rect(t[0],t[1],e,i),this.freeDraw._updateCtxStyle(this.shapeStyle),this.freeDraw.ctx.fill(s),this.freeDraw.ctx.stroke(s),s}_handleMouseMove(t){const{offsetX:e,offsetY:i}=t;if(this.clickedHandlePoint){const s=this.handlePoints[this.clickedHandlePointIndex].point;0===this.clickedHandlePointIndex?(this.width+=(s[0]-e)/this.freeDraw.zoomLevel,this.height+=(s[1]-i)/this.freeDraw.zoomLevel,this.startPoint=[this.startPoint[0]+(e-s[0])/this.freeDraw.zoomLevel,this.startPoint[1]+(i-s[1])/this.freeDraw.zoomLevel]):1===this.clickedHandlePointIndex?(this.width+=(e-s[0])/this.freeDraw.zoomLevel,this.height+=(s[1]-i)/this.freeDraw.zoomLevel,this.startPoint[1]+=(i-s[1])/this.freeDraw.zoomLevel):2===this.clickedHandlePointIndex?(this.width+=(e-s[0])/this.freeDraw.zoomLevel,this.height+=(i-s[1])/this.freeDraw.zoomLevel):3===this.clickedHandlePointIndex&&(this.width+=(s[0]-e)/this.freeDraw.zoomLevel,this.height+=(i-s[1])/this.freeDraw.zoomLevel,this.startPoint[0]+=(e-s[0])/this.freeDraw.zoomLevel),this.freeDraw.eventsReceive.includes("transform")&&this.freeDraw.eventsCallBack(t,this.id,"transform"),this.freeDraw._refreshShapesInCanvas()}else this.clickedShape&&(this.startPoint=[this.startPoint[0]+(e-this.clickedShapePoint[0])/this.freeDraw.zoomLevel,this.startPoint[1]+(i-this.clickedShapePoint[1])/this.freeDraw.zoomLevel],this.clickedShapePoint=[e,i],this.freeDraw.eventsReceive.includes("drag")&&this.freeDraw.eventsCallBack(t,this.id,"drag"),this.freeDraw._refreshShapesInCanvas())}getZoomAndMove(){let t=this.width,e=this.height;t=this.width*this.freeDraw.zoomLevel,e=this.height*this.freeDraw.zoomLevel;let i=(this.startPoint[0]-this.freeDraw.transformCenter[0])*this.freeDraw.zoomLevel+this.freeDraw.transformCenter[0],s=(this.startPoint[1]-this.freeDraw.transformCenter[1])*this.freeDraw.zoomLevel+this.freeDraw.transformCenter[1];return 0!==this.freeDraw.offsetLeft&&(i+=this.freeDraw.offsetLeft),0!==this.freeDraw.offsetTop&&(s+=this.freeDraw.offsetTop),{width:t,height:e,startPoint:[i,s]}}_toSVGPath(){const t=this.freeDraw.fix;this.points[0]=[Number(this.startPoint[0]).toFixed(t),Number(this.startPoint[1]).toFixed(t)],this.points[1]=[Number(this.startPoint[0]+this.width).toFixed(t),Number(this.startPoint[1]).toFixed(t)],this.points[2]=[Number(this.startPoint[0]+this.width).toFixed(t),Number(this.startPoint[1]+this.height).toFixed(t)],this.points[3]=[Number(this.startPoint[0]).toFixed(t),Number(this.startPoint[1]+this.height).toFixed(t)],this.path=`M${this.points[0].join(",")}L${this.points[1].join(",")}L${this.points[2].join(",")}L${this.points[3].join(",")}Z`,this.SVGPath=`<path d="${this.path}" />`}_backupData(){this.startPointBackup=JSON.parse(JSON.stringify(this.startPoint)),this.widthBackup=this.width,this.heightBackup=this.height,this.pointsBackup=JSON.parse(JSON.stringify(this.points))}_rollbackData(){this.startPoint=JSON.parse(JSON.stringify(this.startPointBackup)),this.width=this.widthBackup,this.height=this.heightBackup,this.points=JSON.parse(JSON.stringify(this.pointsBackup))}getHandlePointCoordinate(t){return this.handlePoints[t]?this.handlePoints[t].point:null}};var d=class extends r{constructor(t){super(t),this.x=t.x,this.y=t.y,this.radiusX=t.radiusX,this.radiusY=t.radiusY,this.rotation=t.rotation||0,this.startAngle=t.startAngle||0,this.endAngle=t.endAngle||2*Math.PI,this.anticlockwise=t.anticlockwise||!1,this.xBackup=null,this.yBackup=null,this.radiusXBackup=null,this.radiusYBackup=null,this.rotationBackup=null,this.startAngleBackup=null,this.endAngleBackup=null,this.anticlockwiseBackup=null,this.handleLines=[],this._initEllipse()}_initEllipse(){this._initShape(),this.x&&this.y&&this.radiusX&&this.radiusY&&this._draw()}_generateHandlePointsByPoints(){const{x:t,y:e,radiusX:i,radiusY:s}=this.getZoomAndMove();this.handlePoints[0]={obj:null,point:[t-i,e-s]},this.handlePoints[1]={obj:null,point:[t+i,e-s]},this.handlePoints[2]={obj:null,point:[t+i,e+s]},this.handlePoints[3]={obj:null,point:[t-i,e+s]}}_generateHandleLinesByPoints(){const{x:t,y:e,radiusX:i,radiusY:s}=this.getZoomAndMove();this.handleLines[0]={obj:null,startPoint:[t-i,e-s],endPoint:[t+i,e-s]},this.handleLines[1]={obj:null,startPoint:[t+i,e-s],endPoint:[t+i,e+s]},this.handleLines[2]={obj:null,startPoint:[t+i,e+s],endPoint:[t-i,e+s]},this.handleLines[3]={obj:null,startPoint:[t-i,e+s],endPoint:[t-i,e-s]}}_draw(){this.shape=this._drawEllipse(),this._generateHandleLinesByPoints(),this._generateHandlePointsByPoints(),this.edit&&(this._drawEllipseHandleLines(),this._drawEllipseHandlePoints())}_drawEllipse(){const{x:t,y:e,radiusX:i,radiusY:s,startAngle:n,endAngle:h,anticlockwise:o}=this.getZoomAndMove(),a=new Path2D;return a.ellipse(t,e,i,s,n,h,o),this.freeDraw._updateCtxStyle(this.shapeStyle),this.freeDraw.ctx.fill(a),this.freeDraw.ctx.stroke(a),a}_handleMouseMove(t){let{offsetX:e,offsetY:i}=t;if(this.clickedHandlePoint){const s=this.handlePoints[this.clickedHandlePointIndex].point;if([0,1,2,3].includes(this.clickedHandlePointIndex)){let t=s[0]-e,n=s[1]-i;1===this.clickedHandlePointIndex&&(t=e-s[0]),2===this.clickedHandlePointIndex&&(t=e-s[0],n=i-s[1]),3===this.clickedHandlePointIndex&&(n=i-s[1]),t=this.radiusX+t/this.freeDraw.zoomLevel,n=this.radiusY+n/this.freeDraw.zoomLevel,t>0&&n>0&&(this.radiusX=t,this.radiusY=n)}this.freeDraw.eventsReceive.includes("transform")&&this.freeDraw.eventsCallBack(t,this.id,"transform")}else this.clickedShape&&(this.x+=(e-this.clickedShapePoint[0])/this.freeDraw.zoomLevel,this.y+=(i-this.clickedShapePoint[1])/this.freeDraw.zoomLevel,this.clickedShapePoint=[e,i],this.freeDraw.eventsReceive.includes("drag")&&this.freeDraw.eventsCallBack(t,this.id,"drag"));this.freeDraw._refreshShapesInCanvas()}_drawEllipseHandlePoints(){for(let t=0;t<this.handlePoints.length;t++)this.handlePoints[t].obj=this._drawRectPoint(this.handlePoints[t].point[0],this.handlePoints[t].point[1],this.handlePointStyle.width,{lineWidth:this.handlePointStyle.lineWidth,fillStyle:this.handlePointStyle.fillStyle,strokeStyle:this.handlePointStyle.strokeStyle})}_drawEllipseHandleLines(){for(let t=0;t<this.handleLines.length;t++)this.handleLines[t].obj=this._drawLine(this.handleLines[t].startPoint,this.handleLines[t].endPoint,a)}getZoomAndMove(){let t=this.radiusX*this.freeDraw.zoomLevel,e=this.radiusY*this.freeDraw.zoomLevel,i=(this.x-this.freeDraw.transformCenter[0])*this.freeDraw.zoomLevel+this.freeDraw.transformCenter[0],s=(this.y-this.freeDraw.transformCenter[1])*this.freeDraw.zoomLevel+this.freeDraw.transformCenter[1];return 0!==this.freeDraw.offsetLeft&&(i+=this.freeDraw.offsetLeft),0!==this.freeDraw.offsetTop&&(s+=this.freeDraw.offsetTop),{x:i,y:s,radiusX:t,radiusY:e,rotation:this.rotation,startAngle:this.startAngle,endAngle:this.endAngle,anticlockwise:this.anticlockwise}}_backupData(){this.xBackup=this.x,this.yBackup=this.y,this.radiusXBackup=this.radiusX,this.radiusYBackup=this.radiusY,this.rotationBackup=this.rotation,this.startAngleBackup=this.startAngle,this.endAngleBackup=this.endAngle,this.anticlockwiseBackup=this.anticlockwise}_rollbackData(){this.x=this.xBackup,this.y=this.yBackup,this.radiusX=this.radiusXBackup,this.radiusY=this.radiusYBackup,this.rotation=this.rotationBackup,this.startAngle=this.startAngleBackup,this.endAngle=this.endAngleBackup,this.anticlockwise=this.anticlockwiseBackup}_toSVGPath(){const t=Number(this.x).toFixed(this.freeDraw.fix),e=Number(this.y).toFixed(this.freeDraw.fix),i=Number(this.radiusX).toFixed(this.freeDraw.fix),s=Number(this.radiusY).toFixed(this.freeDraw.fix);this.SVGPath=`<ellipse cx="${t}" cy="${e}" rx="${i}" ry="${s}" />`}getHandlePointCoordinate(t){return this.handlePoints[t]?this.handlePoints[t].point:null}};const f=8;var c=class extends r{constructor(t){super(t),this.temporaryPointsFollow=!0,this.isCreate=!0,this.pointsBackup=[],this.borderPoints=[],this.maxPointCount=t.maxPointCount||50,this._initPolygon()}_initPolygon(){this.handlePointStyle=n,this._initShape(),this.points.length>0&&(this.isCreate=!1,this.temporaryPointsFollow=!1,this._draw())}_draw(){this.shape=this._drawPolygon(),this._generateHandlePointsByPoints(),this._generateBorderPoints(),this.edit&&this._drawPolygonHandlePoints()}_generateHandlePointsByPoints(){const t=this.getZoomAndMove();this.handlePoints=[];for(let e=0;e<t.length;e++)this.handlePoints[e]={obj:null,point:t[e]}}_generateBorderPoints(){let t,e,i,s;const n=this.getZoomAndMove();for(let h=0;h<n.length;h++)t?n[h][0]<t&&(t=n[h][0]):t=n[h][0],e?n[h][0]>e&&(e=n[h][0]):e=n[h][0],i?n[h][1]<i&&(i=n[h][1]):i=n[h][1],s?n[h][1]>s&&(s=n[h][1]):s=n[h][1];this.borderPoints=[[t,i],[e,i],[e,s],[t,s]]}_drawPolygon(){const t=this.getPath(),e=new Path2D(t);return this.freeDraw._updateCtxStyle(this.shapeStyle),this.freeDraw.ctx.fill(e),this.freeDraw.ctx.stroke(e),e}_drawPolygonHandlePoints(){for(let t of this.handlePoints)t.obj=this._drawCirclePoint(t.point[0],t.point[1],this.handlePointStyle.radius,{lineWidth:this.handlePointStyle.lineWidth,fillStyle:this.handlePointStyle.fillStyle,strokeStyle:this.handlePointStyle.strokeStyle})}_handleKeydown(t){this.points.length>0&&t.keyCode===f&&(this.points.pop(),this.freeDraw._refreshShapesInCanvas())}_polygonMouseDown(t){const{offsetX:e,offsetY:i}=t;this.clickedHandlePoint?(this.temporaryPointsFollow=!1,this.temporaryPoints=[],this.temporaryPointsWithoutZoomAndOffset=[]):this.isCreate&&this.points.length<this.maxPointCount&&(this.points.push(this.removePointZoomAndMove([e,i])),this.points.length<this.maxPointCount?this.temporaryPointsFollow=!0:this.temporaryPointsFollow=!1),this.freeDraw._refreshShapesInCanvas()}_handleMouseMove(t){const{offsetX:e,offsetY:i}=t;if(this.clickedHandlePoint)this.points[this.clickedHandlePointIndex]=this.removePointZoomAndMove([e,i]);else if(this.clickedShape){const s=[];for(let t of this.points)s.push([t[0]+(e-this.clickedShapePoint[0])/this.freeDraw.zoomLevel,t[1]+(i-this.clickedShapePoint[1])/this.freeDraw.zoomLevel]);this.clickedShapePoint=[e,i],this.points=s,this.freeDraw.eventsReceive.includes("drag")&&this.freeDraw.eventsCallBack(t,this.id,"drag")}else this.temporaryPointsFollow&&(this.temporaryPoints=[this.removePointZoomAndMove([e,i])],this.temporaryPointsWithoutZoomAndOffset=[[e,i]]);this.freeDraw._refreshShapesInCanvas()}getZoomAndMove(t){const e=[];let i=this.points;t&&(i=i.concat(this.temporaryPoints));for(let t=0;t<i.length;t++){let s=(i[t][0]-this.freeDraw.transformCenter[0])*this.freeDraw.zoomLevel+this.freeDraw.transformCenter[0],n=(i[t][1]-this.freeDraw.transformCenter[1])*this.freeDraw.zoomLevel+this.freeDraw.transformCenter[1];0!==this.freeDraw.offsetLeft&&(s+=this.freeDraw.offsetLeft),0!==this.freeDraw.offsetTop&&(n+=this.freeDraw.offsetTop),e.push([s,n])}return e}removePointZoomAndMove([t,e]){return[(t-this.freeDraw.transformCenter[0]-this.freeDraw.offsetLeft)/this.freeDraw.zoomLevel+this.freeDraw.transformCenter[0],(e-this.freeDraw.transformCenter[1]-this.freeDraw.offsetTop)/this.freeDraw.zoomLevel+this.freeDraw.transformCenter[1]]}_backupData(){this.pointsBackup=JSON.parse(JSON.stringify(this.points))}_rollbackData(){this.points=JSON.parse(JSON.stringify(this.pointsBackup))}getPath(){return"M"+this.getZoomAndMove(!0===this.edit).map(t=>t.join(",")).join("L")+"Z"}_toSVGPath(){this.path="M"+this.points.map(t=>Number(t[0]).toFixed(this.freeDraw.fix)+","+Number(t[1]).toFixed(this.freeDraw.fix)).join("L")+"Z",this.SVGPath=`<path d="${this.path}" />`}getBorderPoint(t){return this.borderPoints[t]}};e.default=class{constructor(t){this.ctx=null,this.canvasDOM=t.canvas,this.eventsCallBack=t.eventsCallBack,this.eventsReceive=t.eventsReceive||["mouseenter","mouseleave"],this.model="view",this.editingId=null,this.isClickedShape=!1,this.clickedShapeId=null,this.shapeInCanvas={},this.zoomLevel=1,this.offsetTop=0,this.offsetLeft=0,this.transformCenter=[0,0],this.eventsKeysMap={},this.fix=2,this._initFreeDraw()}_initFreeDraw(){this.ctx=this.canvasDOM.getContext("2d"),this.canvasDOM.addEventListener("mousedown",this._distributeEvents.bind(this)),this.canvasDOM.addEventListener("mousemove",this._distributeEvents.bind(this)),this.canvasDOM.addEventListener("mouseup",this._distributeEvents.bind(this)),window.document.addEventListener("keydown",this._distributeEvents.bind(this))}_distributeEvents(t){const{type:e,offsetX:i,offsetY:s}=t;if("view"===this.model){if("keydown"===e)return;if("mousedown"===e)for(let t in this.shapeInCanvas)this.shapeInCanvas[t]._includes(i,s)&&(this.clickedShapeId=t,this.isClickedShape=!0);else"mouseup"===e&&(this.clickedShapeId=null,this.isClickedShape=!1);if(this.eventsCallBack&&"function"==typeof this.eventsCallBack)for(let e in this.shapeInCanvas)this.shapeInCanvas[e]._includes(i,s)?this.eventsKeysMap[e]?this.eventsReceive.includes("mousemove")&&this.eventsCallBack(t,e,"mousemove"):(this.eventsKeysMap[e]="mouse-enter",this.eventsReceive.includes("mouseenter")&&this.eventsCallBack(t,e,"mouseenter")):this.eventsKeysMap[e]&&(this.eventsKeysMap[e]=void 0,this.eventsReceive.includes("mouseleave")&&this.eventsCallBack(t,e,"mouseleave"))}else if("edit"===this.model){const n=this.shapeInCanvas[this.editingId];if(n)if(n._trigger(t),"mousedown"===e)n._includes(i,s)&&(this.isClickedShape=!0,this.clickedShapeId=n.id);else if("mouseup"===e)this.isClickedShape=!1,this.clickedShapeId=null;else if("keydown"===e&&13===t.keyCode)for(let t in this.shapeInCanvas){const e=this.shapeInCanvas[t];e.edit&&e.finish()}}}_updateCtxStyle(t){t.lineWidth&&(this.ctx.lineWidth=t.lineWidth),t.fillStyle&&(this.ctx.fillStyle=t.fillStyle),t.strokeStyle&&(this.ctx.strokeStyle=t.strokeStyle)}removeShape(t){return this.shapeInCanvas[t]&&delete this.shapeInCanvas[t],"edit"===this.model&&this.editingId===t&&(this.model="view",this.editingId=null),this._refreshShapesInCanvas(),this}removeAllShape(){return this.shapeInCanvas={},this._refreshShapesInCanvas(),this}_updateModel(t,e){this.model=t||"view",this.editingId=e||null}_clearCanvas(){return this.ctx.clearRect(0,0,this.ctx.canvas.width,this.ctx.canvas.height),this}_refreshShapesInCanvas(){this._clearCanvas();for(let t in this.shapeInCanvas)this.shapeInCanvas[t]._draw()}zoomAndOffset(t,e,i,s){t&&(this.zoomLevel=t),s&&(this.offsetTop=s),i&&(this.offsetLeft=i),e&&(this.transformCenter=e),this._refreshShapesInCanvas()}addShape(t){if("edit"===this.model)throw new Error("Can not add another shape in edit model");const{type:e,id:i}=t;if(!i)throw new Error("Shape id can not be empty");if(this.shapeInCanvas[i])throw new Error(`Shape id must be unique, shape id '${i}' has already exist`);return this._updateModel("edit",i),"rect"===e?(this.shapeInCanvas[i]=this._addRect(t),this.shapeInCanvas[i]):"ellipse"===e?(this.shapeInCanvas[i]=this._addEllipse(t),this.shapeInCanvas[i]):"polygon"===e?(this.shapeInCanvas[i]=new c(Object.assign({},{freeDraw:this},t)),this.shapeInCanvas[i]):void 0}_addRect(t){let{id:e,type:i,shapeStyle:s,handlePointStyle:n,startPoint:h,width:o,height:a,transform:r}=t;if(r){const t=this.removeZoomAndMoveRect(o,a,h);o=t.width,a=t.height,h=t.startPoint}return new l({id:e,type:i,width:o,height:a,startPoint:h,shapeStyle:s,handlePointStyle:n,freeDraw:this})}_addEllipse(t){let{id:e,type:i,shapeStyle:s,handlePointStyle:n,x:h,y:o,radiusX:a,radiusY:r,transform:l}=t;if(l){const t=this.removeZoomAndMoveEllipse(h,o,a,r);h=t.x,o=t.y,a=t.radiusX,r=t.radiusY}return new d({id:e,type:i,x:h,y:o,radiusX:a,radiusY:r,shapeStyle:s,handlePointStyle:n,freeDraw:this})}removeZoomAndMoveRect(t,e,i){t/=this.zoomLevel,e/=this.zoomLevel;let s=i[0],n=i[1];return 0!==this.offsetLeft&&(s-=this.offsetLeft),0!==this.offsetTop&&(n-=this.offsetTop),{width:t,height:e,startPoint:[s=(s-this.transformCenter[0])/this.zoomLevel+this.transformCenter[0],n=(n-this.transformCenter[1])/this.zoomLevel+this.transformCenter[1]]}}removeZoomAndMoveEllipse(t,e,i,s){return i/=this.zoomLevel,s/=this.zoomLevel,0!==this.offsetLeft&&(t-=this.offsetLeft),0!==this.offsetTop&&(e-=this.offsetTop),{x:t=(t-this.transformCenter[0])/this.zoomLevel+this.transformCenter[0],y:e=(e-this.transformCenter[1])/this.zoomLevel+this.transformCenter[1],radiusX:i,radiusY:s}}}}]);